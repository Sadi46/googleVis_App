{
    "collab_server" : "",
    "contents" : "\n\n######################### tables ################################################\n# set rows on 30, until updated\nobserve({\n  updateSliderInput(session, \"row1\",\n                    label = \"How many rows?\",\n                    min=1,\n                    max= nrow(include$data),\n                    value = 30,\n                    step=1)\n})\n\n# Put table in container\n# include <- reactiveValues(data = NULL) : prepaired in 'load and read'\ninclude$table <-\n  DT::renderDataTable(\n    if(is.null(include$data))\n      return()\n    else\n      # isolate inputs\n      isolate({slice(include$data,1:input$row1)}),\n    # allow column selction from client side\n    server= FALSE,\n    extensions = c('Buttons'),\n    selection = list(target = 'column'),\n    # bootstrap necessary for shinytheme visibility\n    style = 'bootstrap',\n    filter = list(position='top',\n                  clear = FALSE,\n                  plain = TRUE),\n    options = list(dom = 'Bfrtip',\n                   scrollY = 300,\n                   #colReorder = TRUE,\n                   scrollX = T,\n                   autoWidth = T,\n                   buttons = c(I('colvis'),\n                               c('copy','csv','excel','pdf','print')),\n                   #class = 'table-condensed',\n                   pageLength = 100 # make scrolling easier,\n    ))\n# with data isolated and table in proxy, changes do not cause direct rerendering\nproxy1 <- dataTableProxy('table1')\n\nobserveEvent(input$showTable1, {\n  output$table1<-  include$table \n})\n\n# visualize selected rows and columns \noutput$info <- renderPrint({\n  req(include$data)\n  cat('Selected rows:\\n\\n')\n  cat(input$table1_rows_all, sep = ', ')\n  cat('\\n\\nSelected columns:\\n\\n')\n  cat(input$table1_columns_selected, sep = ', ')\n})\n\n####################### tab 2 ##################################################\n# \n# observeEvent(input$showTable2, {\n#   output$table2<-  include$subtable\n# }) \n# # Quantile coloring scheme for formatStyle \n# # start the app with one column selected (and therefore colored) (else:error)\n# # clear table\n# observeEvent(input$quantile1,{\n#   updateCheckboxGroupInput(session, \"variable15\",\n#                            choices = colnames(include$subdata),\n#                            inline= input$inline3,\n#                            selected = \"\")\n# })\n# observe({\n#   req(input$variable15) # throws error without\n#   req(input$cut2)\n#   # get quantiles\n#   q<-quantile(as.numeric(include$subdata[,input$variable15]), ######################testen\n#               probs = seq(.05, .95, .05), na.rm = TRUE, names = FALSE)\n#   # replace quantile-cuts from input$cut2\n#   # with actual values depending on variable input\n#   # vectorisation is the fastest solution for replacement; unname is necessary!\n#   replace_vector<-c(\n#          \"5%\" = q[1], \"10%\" = q[2],\n#          \"15%\" = q[3], \"20%\" = q[4],\n#          \"25%\" = q[5], \"30%\" = q[6],\n#          \"35%\" = q[7], \"40%\" = q[8],\n#          \"45%\" = q[9], \"50%\" = q[10],\n#          \"55%\" = q[11], \"60%\" = q[12],\n#          \"65%\" = q[13], \"70%\" = q[14],\n#          \"75%\" = q[15], \"80%\" = q[16],\n#          \"85%\" = q[17], \"90%\" = q[18],\n#          \"95%\" = q[19])\n#     include$cuts <- unname(replace_vector[input$cut2])\n#     # get sequence of white to dark orange; length = 20 for all 5% quantiles\n#     # (often lighter is higher value, but I prefer darker colors; more=more) \n#     include$oranges<-rgb(colorRamp(c(\"white\", \"orangered\"))\n#                         (seq(0, 1,length = length(include$cuts) + 1)), max = 255)\n# })\n# \n# #get colnumber:match(\"b\",names(df))\n# \n# \n# # Put table with data subset in container\n#   include$subtable <-\n#    DT::renderDataTable(\n#       x<-DT::datatable(\n#         # isolate inputs,\n#         # so the table does not rerender on every change, until updated\n#         isolate({include$subdata}),\n#         extensions = c('Buttons'),\n#         selection = list(target = 'column'),\n#         caption = isolate({input$caption1}),\n#         style = 'bootstrap',\n#       filter = list(position='top',\n#                     clear = FALSE,\n#                     plain = TRUE),\n#       options = list(dom = 'Bfrtip',\n#                      scrollY = 300,\n#                      #colReorder = TRUE,\n#                      scrollX = T,\n#                      autoWidth = T,\n#                      buttons = c(I('colvis'),\n#                                  c('copy','csv','excel','pdf','print')),\n#                      #class = 'table-condensed',\n#                      pageLength = 100))# make scrolling easier,\n#      \n#      \n#       # proxy does not work on helperfunctions\n#       # table rerenders when updated with actionButton\n#       \n#       %>% formatCurrency(isolate({input$variable7}), isolate({input$curr1}))\n#       %>% formatRound(isolate({input$variable5}), digits= isolate({input$num1}))\n#       %>% formatPercentage(isolate({input$variable6}), digits=isolate({input$num2}))\n#       %>% formatDate(isolate({input$variable8}), isolate({input$method1}))\n#       \n#       # highlight, row or column, general or conditionally \n#       %>% formatStyle(columns=isolate({input$variable9}),\n#                       valueColumns =isolate({input$variable10}),\n#                       target = isolate({input$target1}),\n#                       # optional highlighting:\n#                       #fontWeight = isolate({input$bold1}),\n#                       color = isolate({input$color1}),\n#                       backgroundColor = isolate({input$color2}))\n#       #vectors of cut-offs and colors - 2 breaks make 3 chunks, so color = +1\n#       %>% formatStyle(columns=isolate({input$variable11}),\n#                       valueColumns =isolate({input$variable12}),\n#                       target = isolate({input$target2}),\n#                       backgroundColor = styleInterval(cuts=isolate({input$cut1}),\n#                                                       values=isolate({input$color3})))\n#       %>% formatStyle(columns=isolate({input$variable13}),\n#                       valueColumns =isolate({input$variable14}),\n#                       target = isolate({input$target3}),\n#                       backgroundColor = styleEqual(levels=isolate({input$level1}),\n#                                                    values=isolate({input$color4})))\n#       %>% formatStyle(columns=isolate({input$variable15}),\n#                       #valueColumns =isolate({input$variable16}),\n#                       target = isolate({input$target4}),\n#                       color = \"black\",\n#                       backgroundColor =\n#                         styleInterval(cuts=isolate({include$cuts}) ,\n#                                       values=isolate({include$oranges})\n#                                             ))\n#       )\n#       \n#   # Convert variable for custom formatPercentage (only adding sign)\n#   observeEvent(input$add1, {\n#     req(input$variable6)\n#     include$subdata[,input$variable6] <- include$subdata[,input$variable6]/100\n#   })\n#   \n#  \n  \n#   proxy2 <- dataTableProxy('table2')\n   \n # On proxy:\n # when replacing the table with same or smaller subset; colums must be the same,\n # so ranges are the same or smaller. \n # filtered cases /columns should be subsetted through subsetbutton\n   \n\n\n",
    "created" : 1496846021518.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3826298750",
    "id" : "56C43913",
    "lastKnownWriteTime" : 1496767276,
    "last_content_update" : 1496767276,
    "path" : "D:/user/Documents/googleVis_App/table.R",
    "project_path" : "table.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}