{
    "collab_server" : "",
    "contents" : "#packageVersion('plotly')  \n# > shiny::runApp(app, display.mode = \"showcase\")\n\n\n\n\n###### stuff that needs to be processed only once ##############################\n# read datasets from included files:\n\n# airquality; source: coursera JHU course\nozone<-import(\"hw1_data.csv\")\n\n# steps: source: coursera JHU course\n# source(\"steps.md\", local=TRUE)\nsteps<-import(\"activity.csv\")\n\n# severe weather events; source: coursera JHU course\nUS_severe_weather_events<-import(\"weather.csv\")\n\n# TODO? get datasets from packages (mtcars is from Base R datasets, no need to get):\n# get(input$datasetName, \"package:datasets\", inherits = FALSE) \n\n#source custom function for inspecting structure of the data\nsource(\"peak.R\", local=TRUE)$value\n\n\n\n############# note ###########\n# inputs are numbered per content ==> adapt depending on UI lay-out\n# (for simplicity and less parentheses, but modularizing is alternative)\n\n# As the widgets return quoted variable names, the use of them has to be\n# like this: dataframe[,\"V\"] \n\n\nshinyServer(function(input, output, session) {\n  \n  # visualize session info # why in console?\n  output$intel<-renderText({\n    str(session)\n  })\n  #display.mode = \"showcase\"\n  #make sure session stops when browser is closed\n  session$onSessionEnded(stopApp)\n  # allow reconnect after greying out\n  session$allowReconnect(TRUE)\n  # prevent a fading out grey screen: \n  tags$head(tags$style(type=\"text/css\",\n                       \"body.disconnected {\n                       background-color: inherit;\n                       opacity: 1;\n}\"\n))\n  \n  \n  ######################## set locale ##########################################\n  # change locale for date analysis and English words in dates\n  # first store actual locale in object to be able to reverse the proces later\n  observeEvent(input$setLocale,{\n    timeLocale<-Sys.getlocale(\"LC_TIME\")\n    Sys.setlocale(\"LC_TIME\", \"C\")\n  })\n  ######################### reset locale if changed before #####################\n  observeEvent(input$resetEnd, {\n    req(input$setLocale)\n    Sys.setlocale(\"LC_TIME\", timeLocale)\n  })\n  \n  #### get code for loading and reading ########################################\n  # run R file from the project folder\n  source(\"load_and_read.R\", local=TRUE)$value\n  \n  \n  #### fill checkboxGroups / source ############################################\n  # run R file from the project folder\n  source(\"updateCheckboxGroupInput.R\", local=TRUE)$value\n  \n  \n  #### make smaller subset #####################################################\n  observeEvent(input$subset1, {\n    if (!is.null(input$variable1))\n      return(include$data <- \n               include$data %>% \n               select(one_of(input$variable1)))\n    if (!is.null(input$variable1b))\n      return(include$data <- \n               include$data %>% \n               select(one_of(input$variable1b)))\n  })\n  \n  ###################### convert variables #####################################\n  \n  #change classes on demand; updating include$data\n  observeEvent(input$convert1,{\n    # prevent error in case the button is clicked without reactive data\n    if (is.null(include$data)) return()\n    # make classes for either chosen checkboxgroup or selected columns in table\n    colNumbers<- input$table1_columns_selected\n    colNames<- input$variable1\n    variables<- input$variable1\n    if (!is.null(colNumbers))\n      return (include$data <-\n                include$data %>%  \n                mutate_at(.cols=colNumbers, .funs=input$class1))\n    if (!is.null(colNames))\n      return (include$data <-\n                include$data %>%  \n                mutate_at(.cols=colNames, .funs=input$class1))\n  })\n  \n  # # convert dates TODO: test (else works)\n  observeEvent(input$convert2,{\n    column<- include$data[,input$variable1]\n    colNames<- input$variable1\n    Count <- input$class2\n    if (Count == \"days since 1900-01-01\"){\n      column <- as.Date(column, origin = \"1900-01-01\")}\n    if (Count == \"Mac Excel\"){\n      column <- as.Date(column, origin = \"1904-01-01\")}\n    if (Count == \"Windows Excel\"){\n      column <- as.Date(column, origin = \"1899-12-30\")}\n    if (Count == \"Matlab\"){\n      column <- as.Date(column, origin = \"1970-01-01\") - 719529}\n    # library(lubridate) can even handle: c(20090101, \"2009-01-02\", \"2009 01 03\",\n    # \"2009-1-4\", \"2009-1, 5\", \"Created on 2009 1 6\", \"200901 !!! 07\")\n    else {include$data <- include$data %>% mutate_at(.cols=colNames, .funs=Count)} \n    })\n  \n  #Force Date class if year or day is missing\n  observeEvent(input$convert4,{\n    req(input$variable1)\n    column<- include$data[,input$variable1]\n    if(input$mode3==\"add day 1\")\n      include$data[,input$variable1]<-as.Date(paste(column,\"01\", sep=\"/\"))\n    if(input$mode3==\"add year 2000\")\n      include$data[,input$variable1]<-as.Date(paste(\"2000\", column, sep=\"/\"))\n    if(input$mode3==\"add day and year\")\n      include$data[,input$variable1]<-as.Date(paste(\"2000\", column,\"01\", sep=\"/\"))\n  })\n  \n  \n  ################## aggregate ###################################################\n  # aggregate(cbind(airquality[,\"Ozone\"] ,airquality[,\"Wind\"]) ~ Month, airquality, mean)\n  # works, but changes variable names in V1 etc\n  # dplyr makes logical names, but needs NA removal if present:\n  \n  # fill input boxes \n  observe({\n    updateSelectInput(session, \"group\",\n                      label = \"Group by\",\n                      choices = c(Choose='', colnames(include$data))) \n  })\n  \n  # make basic function to get correct column name for rounded mean or sd column\n  roundedMean <- function(x)\n    round(mean(x, na.rm = T),digits=3)\n  roundedSd <- function(x)\n    round(sd(x, na.rm = T),digits=3)\n  \n  # fill input boxes\n  observe({\n    updateSelectInput(session, \"summary1\",\n                      label = \"Summary\",\n                      choices = c(\"min(.,na.rm = T)\",\n                                  \"max(.,na.rm=T)\",\n                                  \"roundedMean(.)\", \n                                  \"roundedSd(.)\",\n                                  \"sum(.,na.rm=T)\",\n                                  \"quantile(.,probs=0.05, na.rm=T)\",\n                                  \"quantile(.,probs=0.25, na.rm=T)\",\n                                  \"median(.,na.rm=T)\",\n                                  \"quantile(.,probs=0.75, na.rm=T)\",\n                                  \"quantile(.,probs=0.95, na.rm=T)\" ))\n  })\n  \n  # fill input boxes\n  observe({\n    updateSelectInput(session, \"cols\",\n                      label = \"Columns\",\n                      choices = colnames(include$data)) \n  })\n  # get tabe\n  observeEvent(input$summary2,{\n    include$summary <- \n      include$data %>% \n      group_by(.[,input$group]) %>% \n      summarise_at(.funs= input$summary1, .cols= input$cols) \n    output$summary3<-DT::renderDataTable(\n      include$summary,\n      style = 'bootstrap',\n      options = list(colReorder = TRUE,\n                     scrollX = T,\n                     autoWidth = T)\n      \n    )\n  })\n  # join summaries with original dataframe\n  # first change grouping column in same name as grouping variable \n  # (TODO: rename_at in later dplyr version)\n  observeEvent(input$join,{\n    colnames(include$summary)[1] <- input$group\n    include$data<-full_join(include$data, include$summary, by=input$group)\n  })\n  # \n  # # regroup \n  #     include$summary<-\n  #       include$summary %>% \n  #       # somehow it does not work with column numbers (works in console)\n  #       gather_(key=summary, value=value, include$summary[,-1])\n  \n  \n  \n  ################### change names #############################################\n  observeEvent(input$data8, {\n    req(input$names1)\n    colnames(include$data)[names(include$data) == input$variable1] <-\n      input$names1\n  })\n  \n  # delete rows with table title\n  observeEvent(input$minus_row, {\n    include$data<-\n      include$data %>% slice(-1)\n  })\n  \n  # unite \n  observeEvent(input$convert3,{\n    columns<-input$variable1\n    if(input$mode2 == \"Unite\"){\n      include$data<-\n        include$data %>% \n        unite_(col=input$name1, from=columns, sep=input$sep1)}\n    if(input$mode2 == \"Reshape\"){\n      include$data<-\n        include$data %>% \n        # somehow it does not work with column numbers (works in console)\n        gather_(key=input$name1b, value=input$name1c, columns)}\n  })\n  \n  # split mixed columns\n  observeEvent(input$convert4,{          \n    include$data<-\n      include$data %>% separate(col=input$variable1,\n                                into=c(input$name2))\n  })\n  \n  # reorder columns\n  # with dplyr; negatives to end and positives to front\n  observe({\n    req(include$data)\n    updateSliderInput(session,\"number\", label = \"\",\n                     min = -length(include$data),\n                     max = length(include$data),\n                     step = 1,\n                     value = 0)\n  })\n  observeEvent(input$reorder,{ \n      include$data <-\n        include$data %>% select(input$number, everything())\n  })\n    \n  \n  #check percentage missing values\n  observeEvent(input$NA1, { \n    output$lines2 <- renderPrint({\n      if (!is.null(include$data))\n        return(round(colMeans(is.na(include$data))*100, digits = 1))\n    })\n  })\n  \n  # fix alternative missing values other than NA with a 'closure'\n  # note: (functions that make and return functions; \n  # Closures allow to make functions based on a template), \n  # df[]returns dataframe in stead of a list from lapply\n  \n  # also possible here: fix_missing <- function(x, na.value) {\n  # x[x == na.value] <- NA\n  # x\n  # }\n  observeEvent(input$NA3, {\n    missingValue <-input$NA2\n    fix_missing <- function(missingValue) {\n      function(x) {\n        x[x == missingValue] <- NA\n        x }}\n    include$data[input$variable1] <- \n      lapply(include$data[input$variable1], fix_missing(missingValue))\n  })\n  \n  # add row column \n  observeEvent(input$add,{\n    include$data <- rownames_to_column(include$data, \"row\")\n  })\n  \n  \n  # add column with incomplete cases\n  observeEvent(input$NA4,{\n    if (!is.null(include$data))\n      return (include$data <-\n                include$data %>% \n                mutate(missing = ifelse(complete.cases(.), yes=\"0\", no=\"1\")))\n  })\n  \n  #check zeroes\n  observeEvent(input$null1,{\n    output$lines3 <- renderPrint({\n      if (!is.null(include$data))\n        round(colMeans(include$data==0)*100, digits=1)\n    })\n  })\n  \n \n  ######## make subset for further analysis on page 2: $subdata ################\n  observeEvent(input$subset2, {\n    if (!is.null(input$variable1))\n      return(include$subdata <- \n               include$data %>% \n               select(one_of(input$variable1)))\n    if (!is.null(input$variable1b))\n      return(include$subdata<-\n               include$data %>% \n               select(one_of(input$variable1b)))\n    else include$subdata <- include$filter\n  })\n  ################## switch tabs ###############################################\n  observeEvent(input$link1, {\n    updateTabsetPanel(session, \"Tabset1\", selected=\"googleVis\")\n  })\n  observeEvent(input$link2, {\n    updateTabsetPanel(session, \"Tabset1\", selected=\"steps_markdown\")\n  })\n  observeEvent(input$link3, {\n    updateTabsetPanel(session, \"Tabset1\", selected=\"ozone_markdown\")\n  })\n  observeEvent(input$link4, {\n    updateTabsetPanel(session, \"Tabset1\", selected=\"weather_markdown\")\n  })\n  observeEvent(input$link5, {\n    updateTabsetPanel(session, \"Tabset1\", selected=\"Links\")\n  })\n  # observeEvent(input$link6, {\n  #   updateTabsetPanel(session, \"Tabset1\", selected=\"Load, Read, Convert and Subset\")\n  # })\n  # observeEvent(input$link7, {\n  #   updateTabsetPanel(session, \"Tabset1\", selected=\"Plotly\")\n  # })\n  # observeEvent(input$link8, {\n  #   updateTabsetPanel(session, \"Tabset1\", selected=\"Plotly2\")\n  # })\n  # observeEvent(input$link9, {\n  #   updateTabsetPanel(session, \"Tabset1\", selected=\"Load, Read, Convert and Subset\")\n  # })\n  # observeEvent(input$link10, {\n  #   updateTabsetPanel(session, \"Tabset1\", selected=\"Plotly2\")\n  # })\n  # \n  \n  ################ TABLE ##################\n  # important: a dataset with rownames, has rownames = column 0 in datatable!\n  # JavaScript indexes from 0 instead of 1, \n  # so the index of the n-th element is actually n - 1 \n  # (so n=n when rownames are added ).\n  # table will be rerendered on bigger set, because the ranges can change\n  # some other changes can be done through proxy or actionbutton,\n  # without rerendering immediately\n  \n  ################### show table from source ###################################\n  # run R file from the project folder\n  source(\"table.R\", local=TRUE)$value\n  \n  \n  ################### subset cases #############################################\n  # subset table\n  observeEvent(input$subset3,{\n    filtered_data1 <- input$table1_rows_all\n    include$data <- include$data[filtered_data1,] \n  })\n  \n  \n \n  ############# show table and plot options from source\n  # run R file from the project folder\n  source(\"googleVis_server.R\", local=TRUE)$value\n  })\n\n",
    "created" : 1495790730405.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1513992088",
    "id" : "748F8E65",
    "lastKnownWriteTime" : 1496847103,
    "last_content_update" : 1496847103908,
    "path" : "D:/user/Documents/googleVis_App/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}